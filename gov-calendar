#!/usr/bin/env bash
# Governance Calendar CLI
# User-friendly interface for ~/.claude/governance-calendar.yaml
# Created: 2026-01-24 (ISSUE-111 Phase 2)

set -euo pipefail

CALENDAR_FILE="$HOME/.claude/governance-calendar.yaml"
SCHEDULER_SCRIPT="$HOME/dev/infrastructure/tools/governance-scheduler.sh"
LOCK_FILE="$HOME/.claude/logs/governance-scheduler.lock"
VENV_DIR="$HOME/dev/infrastructure/tools/.venv-governance-scheduler"
PYTHON_BIN="${PYTHON_BIN:-$VENV_DIR/bin/python}"

# Ensure lock directory exists
mkdir -p "$(dirname "$LOCK_FILE")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Ensure Python venv is available
ensure_python() {
    if [[ ! -x "$PYTHON_BIN" ]]; then
        echo "ERROR: Python venv not found: $PYTHON_BIN" >&2
        echo "Create it with:" >&2
        echo "  python3 -m venv --system-site-packages \"$VENV_DIR\"" >&2
        echo "  \"$PYTHON_BIN\" -m pip install --upgrade pip" >&2
        echo "  # If ruamel.yaml not available via system packages:" >&2
        echo "  \"$PYTHON_BIN\" -m pip install ruamel.yaml" >&2
        exit 1
    fi
}

# Show help
show_help() {
    cat << 'EOF'
gov-calendar - Governance Calendar Management

USAGE:
  gov-calendar add "Description" --date YYYY-MM-DD [--time HH:MM] [--remind Nd|Nh]
  gov-calendar list              Show all upcoming events
  gov-calendar due               Show overdue/due-today items
  gov-calendar delete <event_id> Remove one-time event
  gov-calendar test              Send test notification

EXAMPLES:
  gov-calendar add "Review security docs" --date 2026-02-01 --time 14:00 --remind 1d
  gov-calendar add "Check backups" --date 2026-01-30
  gov-calendar list
  gov-calendar due
  gov-calendar delete my_event_123

OPTIONS:
  --date YYYY-MM-DD    Event date (required for add)
  --time HH:MM         Event time (default: 09:00)
  --remind Nd|Nh       Reminder before event (e.g., 1d, 2h, 30m)

EOF
}

# Generate event ID from description
generate_event_id() {
    local desc="$1"
    # Convert to lowercase, replace spaces/special chars with underscore, truncate
    echo "$desc" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '_' | cut -c1-40
}

# Parse reminder string (e.g., "1d", "2h", "30m") to minutes
parse_reminder() {
    local remind="$1"
    if ! [[ "$remind" =~ ^[0-9]+[dhm]$ ]]; then
        echo "ERROR: Invalid reminder format. Use Nd, Nh, or Nm" >&2
        exit 1
    fi
    local value="${remind%[dhm]}"
    local unit="${remind: -1}"

    case "$unit" in
        d) echo $((value * 1440)) ;;  # days to minutes
        h) echo $((value * 60)) ;;    # hours to minutes
        m) echo "$value" ;;           # minutes
        *) echo "ERROR: Invalid reminder format. Use Nd, Nh, or Nm" >&2; exit 1 ;;
    esac
}

# Acquire exclusive lock to prevent concurrent writes
acquire_lock() {
    exec 200>"$LOCK_FILE"
    if ! flock -w 10 200; then
        echo "ERROR: Could not acquire lock: $LOCK_FILE" >&2
        exit 1
    fi
}

# Add one-time event
add_event() {
    local description=""
    local date=""
    local time="09:00"
    local remind_before="0"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --date)
                date="$2"
                shift 2
                ;;
            --time)
                time="$2"
                shift 2
                ;;
            --remind)
                remind_before=$(parse_reminder "$2")
                shift 2
                ;;
            *)
                if [[ -z "$description" ]]; then
                    description="$1"
                    shift
                else
                    echo "ERROR: Unknown argument: $1" >&2
                    exit 1
                fi
                ;;
        esac
    done

    # Validate
    if [[ -z "$description" ]]; then
        echo "ERROR: Description required" >&2
        exit 1
    fi

    if [[ -z "$date" ]]; then
        echo "ERROR: --date required" >&2
        exit 1
    fi

    # Validate date format
    if ! date -d "$date" &>/dev/null; then
        echo "ERROR: Invalid date format. Use YYYY-MM-DD" >&2
        exit 1
    fi

    # Validate time format
    if ! [[ "$time" =~ ^([01][0-9]|2[0-3]):[0-5][0-9]$ ]]; then
        echo "ERROR: Invalid time format. Use HH:MM" >&2
        exit 1
    fi

    local event_id
    event_id=$(generate_event_id "$description")
    if [[ -z "$event_id" ]]; then
        echo "ERROR: Description must contain at least one alphanumeric character" >&2
        exit 1
    fi

    # Add to YAML using Python
    ensure_python
    acquire_lock
    "$PYTHON_BIN" - "$CALENDAR_FILE" "$event_id" "$description" "$date" "$time" "$remind_before" << 'PYTHON'
import yaml
import sys
import os
import re
import tempfile

calendar_file = os.path.expanduser(sys.argv[1])
event_id = sys.argv[2]
description = sys.argv[3]
date = sys.argv[4]
time = sys.argv[5]
remind_before = int(sys.argv[6])

TIME_RE = re.compile(r"^\\d{1,2}:\\d{2}$")
DATE_RE = re.compile(r"^\\d{4}-\\d{2}-\\d{2}$")
ISO_RE = re.compile(r"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}")

try:
    from ruamel.yaml import YAML
    from ruamel.yaml.scalarstring import DoubleQuotedScalarString
    _RUAMEL = True
except Exception:
    _RUAMEL = False

if not _RUAMEL:
    class Quoted(str):
        pass

    def quoted_representer(dumper, data):
        return dumper.represent_scalar("tag:yaml.org,2002:str", data, style='"')

    yaml.SafeDumper.add_representer(Quoted, quoted_representer)

def new_yaml_rt():
    if _RUAMEL:
        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True
        return yaml_rt
    return None

def quote_scalar(value: str):
    if _RUAMEL:
        return DoubleQuotedScalarString(value)
    return Quoted(value)

def load_yaml(path):
    if _RUAMEL:
        yaml_rt = new_yaml_rt()
        with open(path) as f:
            return yaml_rt, (yaml_rt.load(f) or {})
    with open(path) as f:
        return None, (yaml.safe_load(f) or {})

def dump_yaml(data, file_obj, yaml_rt=None):
    if _RUAMEL:
        yaml_rt.dump(data, file_obj)
    else:
        yaml.safe_dump(data, file_obj, default_flow_style=False, sort_keys=False)

def quote_strings(obj):
    if isinstance(obj, dict):
        for key in list(obj.keys()):
            obj[key] = quote_strings(obj[key])
        return obj
    if isinstance(obj, list):
        for idx in range(len(obj)):
            obj[idx] = quote_strings(obj[idx])
        return obj
    if isinstance(obj, str) and (TIME_RE.match(obj) or DATE_RE.match(obj) or ISO_RE.match(obj)):
        return quote_scalar(obj)
    return obj

def atomic_write(path, data, yaml_rt=None):
    dir_name = os.path.dirname(path) or "."
    os.makedirs(dir_name, exist_ok=True)
    fd, tmp_path = tempfile.mkstemp(prefix=".governance-calendar.", suffix=".tmp", dir=dir_name)
    try:
        with os.fdopen(fd, "w") as f:
            dump_yaml(data, f, yaml_rt)
        os.replace(tmp_path, path)
    finally:
        try:
            os.unlink(tmp_path)
        except FileNotFoundError:
            pass

try:
    if os.path.exists(calendar_file):
        yaml_rt, config = load_yaml(calendar_file)
    else:
        yaml_rt = new_yaml_rt()
        config = {}

    if not isinstance(config, dict):
        raise ValueError("Calendar file must contain a YAML mapping at top level")

    # Ensure one_time section exists
    if 'one_time' not in config:
        config['one_time'] = {}

    # Check if event_id already exists
    if event_id in config['one_time']:
        print(f"ERROR: Event ID '{event_id}' already exists. Choose a different description.", file=sys.stderr)
        sys.exit(1)

    # Add event
    config['one_time'][event_id] = {
        'description': description,
        'date': date,
        'time': time,
        'message': f"ðŸ“… {description}",
    }

    if remind_before > 0:
        config['one_time'][event_id]['notify_before_minutes'] = remind_before

    config['one_time'][event_id]['priority'] = 'default'
    config['one_time'][event_id]['tags'] = 'calendar,user_added'

    # Write back
    config = quote_strings(config)
    atomic_write(calendar_file, config, yaml_rt)

    print(f"âœ… Added event: {event_id}")
    print(f"   Description: {description}")
    print(f"   Date/Time: {date} {time}")
    if remind_before > 0:
        print(f"   Reminder: {remind_before} minutes before")

except Exception as e:
    print(f"ERROR: {e}", file=sys.stderr)
    sys.exit(1)
PYTHON
}

# List all events
list_events() {
    ensure_python
    "$PYTHON_BIN" << 'PYTHON'
import yaml
import os
import re
from datetime import datetime, timedelta

calendar_file = os.path.expanduser("~/.claude/governance-calendar.yaml")

def clean(text: str) -> str:
    return re.sub(r'[\x00-\x1F\x7F-\x9F]', '', str(text))

try:
    with open(calendar_file) as f:
        config = yaml.safe_load(f) or {}
except FileNotFoundError:
    print("No calendar file found.")
    raise SystemExit(0)

if not isinstance(config, dict):
    print("Calendar file is not a YAML mapping.")
    raise SystemExit(1)

now = datetime.now()
print(f"\033[1;34m=== Governance Calendar ===\033[0m")
print(f"Current: {now.strftime('%A %Y-%m-%d %H:%M')}\n")

# Recurring events
print("\033[1;32mRecurring Events:\033[0m")
recurring = config.get('recurring', {})
if not recurring:
    print("  (none)")
else:
    for event_id, event in recurring.items():
        desc = clean(event.get('description', event_id))
        schedule = event.get('schedule', '')
        notify = event.get('notify_before_minutes', 0)
        notify_str = f" (remind {notify}min before)" if notify > 0 else ""
        print(f"  â€¢ {desc}")
        print(f"    {schedule}{notify_str}")

print()

# One-time events
print("\033[1;32mOne-Time Events:\033[0m")
one_time = config.get('one_time', {})
if not one_time:
    print("  (none)")
else:
    # Sort by date
    events_sorted = sorted(
        one_time.items(),
        key=lambda x: f"{x[1].get('date', '9999-99-99')} {x[1].get('time', '00:00')}"
    )

    for event_id, event in events_sorted:
        safe_id = clean(event_id)
        desc = clean(event.get('description', event_id))
        date = event.get('date', '')
        time = event.get('time', '09:00')

        # Check if past/future
        try:
            event_dt = datetime.strptime(f"{date} {time}", "%Y-%m-%d %H:%M")
            status = ""
            if event_dt < now:
                status = " \033[0;31m[OVERDUE]\033[0m"
            elif event_dt.date() == now.date():
                status = " \033[1;33m[TODAY]\033[0m"
            print(f"  â€¢ [{safe_id}] {desc}{status}")
            print(f"    {date} {time}")
        except:
            print(f"  â€¢ [{safe_id}] {desc}")
            print(f"    {date} {time}")

print()

# Completed events
completed = config.get('completed', {})
if completed:
    print(f"\033[2mCompleted: {len(completed)} event(s)\033[0m")
PYTHON
}

# Show due/overdue items
show_due() {
    ensure_python
    "$PYTHON_BIN" << 'PYTHON'
import yaml
import os
import re
from datetime import datetime

calendar_file = os.path.expanduser("~/.claude/governance-calendar.yaml")

def clean(text: str) -> str:
    return re.sub(r'[\x00-\x1F\x7F-\x9F]', '', str(text))

try:
    with open(calendar_file) as f:
        config = yaml.safe_load(f) or {}
except FileNotFoundError:
    print("No calendar file found.")
    raise SystemExit(0)

if not isinstance(config, dict):
    print("Calendar file is not a YAML mapping.")
    raise SystemExit(1)

now = datetime.now()
current_day = now.strftime("%A")
current_time = now.strftime("%H:%M")

print("\033[1;33m=== Due Today / Overdue ===\033[0m\n")

found_any = False

# Check recurring events for today
recurring = config.get('recurring', {})
for event_id, event in recurring.items():
    schedule = event.get('schedule', '')
    parts = schedule.split()

    if len(parts) == 2:
        day_part, time_part = parts
        if day_part == current_day:
            desc = clean(event.get('description', event_id))
            status = "DUE TODAY" if current_time >= time_part else "UPCOMING TODAY"
            print(f"\033[1;33m[{status}]\033[0m {desc}")
            print(f"  Schedule: {schedule}\n")
            found_any = True

# Check one-time events
one_time = config.get('one_time', {})
for event_id, event in one_time.items():
    date = event.get('date', '')
    time = event.get('time', '09:00')

    try:
        event_dt = datetime.strptime(f"{date} {time}", "%Y-%m-%d %H:%M")
        if event_dt.date() == now.date():
            desc = clean(event.get('description', event_id))
            status = "DUE NOW" if now >= event_dt else "DUE TODAY"
            print(f"\033[1;33m[{status}]\033[0m {desc}")
            print(f"  {date} {time}\n")
            found_any = True
        elif event_dt < now:
            desc = clean(event.get('description', event_id))
            days_overdue = (now - event_dt).days
            print(f"\033[0;31m[OVERDUE {days_overdue}d]\033[0m {desc}")
            print(f"  {date} {time}\n")
            found_any = True
    except:
        pass

if not found_any:
    print("âœ… No items due or overdue\n")
PYTHON
}

# Delete one-time event
delete_event() {
    local event_id="$1"

    if [[ -z "$event_id" ]]; then
        echo "ERROR: Event ID required" >&2
        echo "Usage: gov-calendar delete <event_id>" >&2
        exit 1
    fi
    if ! [[ "$event_id" =~ ^[a-z0-9_]{1,40}$ ]]; then
        echo "ERROR: Invalid event ID format" >&2
        exit 1
    fi

    acquire_lock
    ensure_python
    "$PYTHON_BIN" - "$CALENDAR_FILE" "$event_id" << 'PYTHON'
import yaml
import sys
import os
import re
import tempfile

calendar_file = os.path.expanduser(sys.argv[1])
event_id = sys.argv[2]

TIME_RE = re.compile(r"^\\d{1,2}:\\d{2}$")
DATE_RE = re.compile(r"^\\d{4}-\\d{2}-\\d{2}$")
ISO_RE = re.compile(r"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}")

try:
    from ruamel.yaml import YAML
    from ruamel.yaml.scalarstring import DoubleQuotedScalarString
    _RUAMEL = True
except Exception:
    _RUAMEL = False

if not _RUAMEL:
    class Quoted(str):
        pass

    def quoted_representer(dumper, data):
        return dumper.represent_scalar("tag:yaml.org,2002:str", data, style='"')

    yaml.SafeDumper.add_representer(Quoted, quoted_representer)

def new_yaml_rt():
    if _RUAMEL:
        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True
        return yaml_rt
    return None

def quote_scalar(value: str):
    if _RUAMEL:
        return DoubleQuotedScalarString(value)
    return Quoted(value)

def load_yaml(path):
    if _RUAMEL:
        yaml_rt = new_yaml_rt()
        with open(path) as f:
            return yaml_rt, (yaml_rt.load(f) or {})
    with open(path) as f:
        return None, (yaml.safe_load(f) or {})

def dump_yaml(data, file_obj, yaml_rt=None):
    if _RUAMEL:
        yaml_rt.dump(data, file_obj)
    else:
        yaml.safe_dump(data, file_obj, default_flow_style=False, sort_keys=False)

def quote_strings(obj):
    if isinstance(obj, dict):
        for key in list(obj.keys()):
            obj[key] = quote_strings(obj[key])
        return obj
    if isinstance(obj, list):
        for idx in range(len(obj)):
            obj[idx] = quote_strings(obj[idx])
        return obj
    if isinstance(obj, str) and (TIME_RE.match(obj) or DATE_RE.match(obj) or ISO_RE.match(obj)):
        return quote_scalar(obj)
    return obj

def atomic_write(path, data, yaml_rt=None):
    dir_name = os.path.dirname(path) or "."
    os.makedirs(dir_name, exist_ok=True)
    fd, tmp_path = tempfile.mkstemp(prefix=".governance-calendar.", suffix=".tmp", dir=dir_name)
    try:
        with os.fdopen(fd, "w") as f:
            dump_yaml(data, f, yaml_rt)
        os.replace(tmp_path, path)
    finally:
        try:
            os.unlink(tmp_path)
        except FileNotFoundError:
            pass

try:
    if os.path.exists(calendar_file):
        yaml_rt, config = load_yaml(calendar_file)
    else:
        yaml_rt = new_yaml_rt()
        config = {}

    if not isinstance(config, dict):
        raise ValueError("Calendar file must contain a YAML mapping at top level")

    one_time = config.get('one_time', {})

    if event_id not in one_time:
        print(f"ERROR: Event ID '{event_id}' not found", file=sys.stderr)
        sys.exit(1)

    # Remove event
    desc = one_time[event_id].get('description', event_id)
    del one_time[event_id]

    # Write back
    config = quote_strings(config)
    atomic_write(calendar_file, config, yaml_rt)

    print(f"âœ… Deleted event: {event_id}")
    print(f"   Description: {desc}")

except Exception as e:
    print(f"ERROR: {e}", file=sys.stderr)
    sys.exit(1)
PYTHON
}

# Test notification
test_notification() {
    if [[ -x "$SCHEDULER_SCRIPT" ]]; then
        "$SCHEDULER_SCRIPT" test
    else
        echo "ERROR: Scheduler script not found or not executable: $SCHEDULER_SCRIPT" >&2
        exit 1
    fi
}

# Main
case "${1:-}" in
    add)
        shift
        add_event "$@"
        ;;
    list|ls)
        list_events
        ;;
    due)
        show_due
        ;;
    delete|rm)
        shift
        delete_event "$@"
        ;;
    test)
        test_notification
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "ERROR: Unknown command: ${1:-}" >&2
        echo "Run 'gov-calendar help' for usage" >&2
        exit 1
        ;;
esac
